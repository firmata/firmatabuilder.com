/*!
 * Copyright 2015 Jeff Hoefs under the terms of the MIT license found at
 * https://github.com/firmata/firmata-builder/blob/master/LICENSE-MIT
 */

var _ = require('lodash');
var coreFeatures = require("../lib/coreFeatures.js");
var contributedFeatures = require("../lib/contributedFeatures");
var allFeatures = _.extend(_.clone(coreFeatures), contributedFeatures);

var analogInputEnabled;
var analogOutputEnabled;
var digitalInputEnabled;
var digitalOutputEnabled;
var servoEnabled;
var schedulerEnabled;

/**
 * Additional features should not be added to this function.
 * Ideally these comparisons will be eliminated at some point.
 * @private
 */
function setEnabledFeatures(selectedFeature) {
  switch (selectedFeature) {
  case "AnalogInputFirmata":
    analogInputEnabled = true;
    break;
  case "AnalogOutputFirmata":
    analogOutputEnabled = true;
    break;
  case "DigitalInputFirmata":
    digitalInputEnabled = true;
    break;
  case "DigitalOutputFirmata":
    digitalOutputEnabled = true;
    break;
  case "ServoFirmata":
    servoEnabled = true;
    break;
  case "FirmataScheduler":
    schedulerEnabled = true;
    break;
  }
}

function clearEnabledFeatures() {
  analogInputEnabled = false;
  analogOutputEnabled = false;
  digitalInputEnabled = false;
  digitalOutputEnabled = false;
  servoEnabled = false;
  schedulerEnabled = false;
}

/**
 * @module builder
 * Given a set of Firmata features and options, generates text for an Arduino
 * .ino file.
 */
var builder = {

  allFeatures: allFeatures,

  /**
   * @param {Object} data User selected features and options
   * @return {String} The text for the .ino file
   */
  build: function(data) {
    var outputText = "";

    // TODO - decide whether or not to throw an error
    if (typeof data === "undefined") {
      console.error("No data passed to build method");
      return;
    }

    // TODO - decide whether or not to throw an error
    if (typeof data.selectedFeatures === "undefined" || data.selectedFeatures.length < 1) {
      console.error("No features selected.");
      return;
    }

    this.featuresWithReporting = [];
    this.featuresWithUpdate = [];
    this.dependencies = Object.create(null);
    this.updateEnabled = false;
    this.reportingEnabled = false;

    this.filename = data.filename || "ConfiguredFirmata";
    this.connectionType = data.connectionType || {serial: {baud: 57600}};
    this.selectedFeatures = data.selectedFeatures;

    this.processFeatureSelection();

    outputText += this.createHeader();
    outputText += this.createIncludes();
    outputText += this.createPostDependencies();
    outputText += this.createSystemResetCallbackFn();
    outputText += this.createSetupFn();
    outputText += this.createLoopFn();

    return outputText;
  },

  /**
   * @private
   */
  processFeatureSelection: function() {
    var len = this.selectedFeatures.length;

    clearEnabledFeatures();
    for (var i = 0; i < len; i++) {
      setEnabledFeatures(this.selectedFeatures[i]);
      var feature = this.allFeatures[this.selectedFeatures[i]];

      if (feature.reporting) {
        this.featuresWithReporting.push(feature);
      }
      if (feature.update) {
        this.featuresWithUpdate.push(feature);
      }
    }

    if (this.featuresWithReporting.length > 0) {
      this.reportingEnabled = true;
    }

    if (this.featuresWithUpdate.length > 0) {
      this.updateEnabled = true;
    }
  },

  /**
   * @private
   */
  createHeader: function() {
    var date = new Date();
    var header = "/*\n * " + this.filename + ".ino generated by FirmataBuilder\n";
    header += " * " + date.toString() + "\n */\n\n";
    return header;
  },

  /**
   * @private
   */
  createIncludes: function() {
    var includes = "#include <ConfigurableFirmata.h>\n\n";

    for (var i = 0, len = this.selectedFeatures.length; i < len; i++) {
      var feature = this.allFeatures[this.selectedFeatures[i]];

      if (feature.dependencies) {
        for (var j = 0; j < feature.dependencies.length; j++) {
          var d = feature.dependencies[j];
          // prevent duplicate includes
          if (!this.dependencies[d.className]) {
            includes += "#include <" + d.className + ".h>\n";
            this.dependencies[d.className] = true;
          }
        }
      }

      includes += "#include <" + feature.className + ".h>\n";
      includes += feature.className + " " + feature.instanceName + ";\n\n";
    }

    // always include FirmataExt
    includes += "#include <FirmataExt.h>\n";
    includes += "FirmataExt firmataExt;\n\n";

    return includes;
  },

  /**
   * Dependencies that should be included after the initial set of included files.
   * @private
   */
  createPostDependencies: function() {
    var includes = "";
    if (analogOutputEnabled || servoEnabled) {
      includes += "#include <AnalogWrite.h>\n\n";
    }
    if (this.reportingEnabled) {
      includes += "#include <FirmataReporting.h>\n";
      includes += "FirmataReporting reporting;\n\n";
    }
    return includes;
  },

  /**
   * @private
   */
  createSystemResetCallbackFn: function() {
    var fn = "void systemResetCallback()\n";
    fn += "{\n";
    fn += "  for (byte i = 0; i < TOTAL_PINS; i++) {\n";
    fn += "    if (IS_PIN_ANALOG(i)) {\n";

    if (analogInputEnabled) {
      fn += "      Firmata.setPinMode(i, ANALOG);\n";
    }

    fn += "    } else if (IS_PIN_DIGITAL(i)) {\n";

    if (digitalOutputEnabled) {
      fn += "      Firmata.setPinMode(i, OUTPUT);\n";
    }

    fn += "    }\n";
    fn += "  }\n";

    fn += "  firmataExt.reset();\n";

    fn += "}\n\n";
    return fn;
  },

  /**
   * @private
   */
  createSetupFn: function() {
    var fn = "void setup()\n";
    fn += "{\n";

    fn += "  Firmata.setFirmwareVersion(FIRMATA_MAJOR_VERSION, FIRMATA_MINOR_VERSION);\n\n";

    if (analogOutputEnabled || servoEnabled) {
      fn += "  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);\n\n";
    }

    for (var i = 0, len = this.selectedFeatures.length; i < len; i++) {
      var feature = this.allFeatures[this.selectedFeatures[i]];
      fn += "  firmataExt.addFeature(" + feature.instanceName + ");\n";
    }

    if (this.reportingEnabled) {
      fn += "  firmataExt.addFeature(reporting);\n\n";
    }

    fn += "  Firmata.attach(SYSTEM_RESET, systemResetCallback);\n\n";

    if (this.connectionType.serial) {
      fn += "  Firmata.begin(" + this.connectionType.serial.baud + ");\n\n";
    }

    fn += "  systemResetCallback();\n";

    fn += "}\n\n";
    return fn;
  },

  /**
   * @private
   */
  createLoopFn: function() {
    var fn = "void loop()\n";
    fn += "{\n";

    if (digitalInputEnabled) {
      fn += "  digitalInput.report();\n\n";
    }

    fn += "  while(Firmata.available()) {\n";
    fn += "    Firmata.processInput();\n";

    if (schedulerEnabled) {
      fn += "    if (!Firmata.isParsingMessage()) {\n";
      fn += "      goto runtasks;\n";
      fn += "    }\n";
      fn += "  }\n"; // end while (if scheduler)
      fn += "  if (!Firmata.isParsingMessage()) {\n";
      fn += "runtasks: scheduler.runTasks();\n";
    }

    // if scheduler end if, else end while
    fn += "  }\n\n";

    if (this.reportingEnabled) {
      var numReporting = this.featuresWithReporting.length;
      fn += "  if (reporting.elapsed()) {\n";
      for (var i = 0; i < numReporting; i++) {
        fn += ("    " + this.featuresWithReporting[i].instanceName + ".report();\n");
      }
      fn += "  }\n\n";
    }

    if (this.updateEnabled) {
      var numUpdate = this.featuresWithUpdate.length;
      for (var k = 0; k < numUpdate; k++) {
        fn += ("  " + this.featuresWithUpdate[k].instanceName + ".update();\n");
      }
    }

    fn += "}\n";
    return fn;
  }

};

module.exports = builder;
